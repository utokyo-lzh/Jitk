<!DOCTYPE html>
<html>
<title>Ideas</title>
<xmp theme="united" style="display:none;">

For now, this is a general infrastructure for creating kernel extensions.

* Define a DSL that the kernel accepts; the DSL spec
guarantees safety (e.g., no buffer overflow, no division by zero, or even no loops).

* Implement a compiler that translates a DSL program to machine instructions.

* Prove that the compiler is correct wrt the spec.

It would be great if we can extend this scheme to other kernel
components, such as filesystems, drivers,
and the [security subsystem](http://kernsec.org/wiki/index.php/Projects).

NB: ramfs looks simple, but others may be too complicated..

NB: maybe we should get their specifications first.

NB: we probably need to prove the RTL program never invokes undefined behavior.

NB: when CompCert doesn't work (e.g., no x86-64 backend), consider to invoke gcc or llvm
for code generation.  We then should at least do translation validation.  That means
we need to convert RTL to LLVM IR.

## Proof

The overall goal is to do backward simulation (refinement),
to proof that all possible behaviors of the IL are legal behaviors in the DSL.
This is hard to do in general.  So we can instead do forward simulation,
to proof that the IL has all good behaviors of the DSL,
and that the IL is deterministic, which gets backward simulation.
CompCert seems to have a nice library
[Smallstep.v](http://compcert.inria.fr/doc/html/Smallstep.html) that deals with the details.

See also:
[Forward and Backward Simulations Part I: Untimed Systems](http://groups.csail.mit.edu/tds/papers/Lynch/TM-486.pdf), from Nancy.

Another interesting choice is the IL.
We could use low-level RTL, Cminor, or even Clight (a subset of C,
where we can directly invoke gcc/clang for better optimizations).
Not sure which one is easier to do proof.

See also:
[Verified Just-In-Time Compiler on x86](http://www.cl.cam.ac.uk/~mom22/jit/jit.pdf),
from POPL 2010.

## Syscall filtering

[seccomp](http://lwn.net/Articles/498231/).
Optmizations across filters may also be interesting (see DPF).

## Packet filtering

[BPF](http://www.tcpdump.org/papers/bpf-usenix93.pdf)
[DPF](http://pdos.csail.mit.edu/~engler/dpf.html)

## Syscall batching

Xen's [multicall](http://lxr.linux.no/linux/arch/x86/xen/multicalls.h).

Linux's
[syslet proposal](http://people.redhat.com/mingo/syslet-patches/patches/async-core-docs.patch)
allows one to abort the execution of multiple syscalls on error,
such as the
[`SYSLET_STOP_ON_NEGATIVE` flag](http://lwn.net/Articles/221913/).

<span style="font-variant: small-caps">CompositeCall</span>:
[Using Interpreted <span style="font-variant: small-caps">CompositeCall</span>s to Improve Operating System Services](http://choices.cs.uiuc.edu/uChoices/Papers/fabio/2k/htdocs/CompositeCall-spe.pdf), from UIUC.
This is an interpreter that supports arithmetic operations and branching.

## Tracing

[ktap](http://www.ktap.org/) uses a bytecode interpreter in kernel.

## UEFI

[EFI byte code virtual machine](http://www.uefi.org/sites/default/files/resources/UEFI_2.4_0.pdf) (page 949)

## General scripting

Lua in [NetBSD](http://www.phoronix.com/scan.php?page=news_item&px=MTQ4ODk).

## DSL for drivers

[Devil](https://www.usenix.org/conference/osdi-2000/devil-idl-hardware-programming),
OSDI 2000.

[NDL](http://www.cs.nyu.edu/~cconway/papers/conway-2004-LCTES-ndl.pdf)

DSL for [video device drivers](https://www.usenix.org/conference/dsl-97/domain-specific-language-video-device-drivers-design-implementation)

</xmp>
<script src="assets/strapdown.js"></script>
</html>
