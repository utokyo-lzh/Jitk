<!DOCTYPE html>
<html>
<title>Ideas</title>
<xmp theme="united" style="display:none;">

For now, this is a general infrastructure for creating kernel extensions.

* Define a DSL that the kernel accepts; the DSL spec
guarantees safety (e.g., no buffer overflow, no division by zero, or even no loops).

* Implement a compiler that translates a DSL program to machine instructions.

* Prove that the compiler is correct wrt the spec.

It would be great if we can extend this scheme to other kernel
components, such as filesystems, drivers,
and the [security subsystem](http://kernsec.org/wiki/index.php/Projects).

NB: prove higher-level security properties (rather than memory safety, etc.)?

NB: ramfs looks simple, but others may be too complicated..

NB: we need to prove the generated program never invokes undefined behavior.
To do so, we need to prove the original program (e.g., seccomp), once accepted,
never invokes undefined behavior---undefined code is not allowed in the kernel.

NB: when CompCert doesn't work (e.g., no x86-64 backend), consider to invoke gcc or llvm
for code generation.  We then should at least do translation validation.  That means
we need to convert RTL to LLVM IR.

## Proof

The overall goal is to do backward simulation (refinement),
to proof that all possible behaviors of the IL are legal behaviors in the DSL.
This is hard to do in general.  So we can instead do forward simulation,
to proof that the IL has all good behaviors of the DSL,
and that the IL is deterministic, which gets backward simulation.
CompCert seems to have a nice library
[Smallstep.v](http://compcert.inria.fr/doc/html/Smallstep.html) that deals with the details.

See also:
[Forward and Backward Simulations Part I: Untimed Systems](http://groups.csail.mit.edu/tds/papers/Lynch/TM-486.pdf), from Nancy.

Another interesting choice is the IL.
Cminor seems to be the right choice.
The RTL is too low-level (i.e., architecture-specific)
and requires global numbering of instructions,
which makes it much harder to prove anything.
Clight and Csharpminor
involve too much C detail, such as signed/unsigned integer types,
which we often don't really care.

See also:
[Verified Just-In-Time Compiler on x86](http://www.cl.cam.ac.uk/~mom22/jit/jit.pdf),
from POPL 2010.

## Syscall filtering

[seccomp](http://lwn.net/Articles/498231/).
Optmizations across filters may also be interesting (see DPF).

## Packet filtering

[BPF](http://www.tcpdump.org/papers/bpf-usenix93.pdf)
[DPF](http://pdos.csail.mit.edu/~engler/dpf.html)

## Syscall batching

Xen's [multicall](http://lxr.linux.no/linux/arch/x86/xen/multicalls.h).

Linux's
[syslet proposal](http://people.redhat.com/mingo/syslet-patches/patches/async-core-docs.patch)
allows one to abort the execution of multiple syscalls on error,
such as the
[`SYSLET_STOP_ON_NEGATIVE` flag](http://lwn.net/Articles/221913/).

<span style="font-variant: small-caps">CompositeCall</span>:
[Using Interpreted <span style="font-variant: small-caps">CompositeCall</span>s to Improve Operating System Services](http://choices.cs.uiuc.edu/uChoices/Papers/fabio/2k/htdocs/CompositeCall-spe.pdf), from UIUC.
This is an interpreter that supports arithmetic operations and branching.

## Tracing

[ktap](http://www.ktap.org/) uses a bytecode interpreter in kernel.

## UEFI

[EFI byte code virtual machine](http://www.uefi.org/sites/default/files/resources/UEFI_2.4_0.pdf) (page 949)

## General scripting

Lua in [NetBSD](http://www.phoronix.com/scan.php?page=news_item&px=MTQ4ODk).

## DSL for drivers

[Devil](https://www.usenix.org/conference/osdi-2000/devil-idl-hardware-programming),
OSDI 2000.  See more information on its [project page](http://phoenix.inria.fr/software/past-projects/devil).

GAL: [video device drivers](https://www.usenix.org/conference/dsl-97/domain-specific-language-video-device-drivers-design-implementation)

[NDL](http://www.cs.nyu.edu/~cconway/papers/conway-2004-LCTES-ndl.pdf) and its
[project page](http://www.cs.nyu.edu/~cconway/ndl/)

[Termite](http://www.sigops.org/sosp/sosp09/papers/ryzhyk-sosp09.pdf), SOSP 2009.

[Rathaxes](http://www.rathaxes.org/)

## Systems programming with Idris

[Resource-safe Systems Programming with Embedded Domain Specific Languages](http://www.cs.st-andrews.ac.uk/~eb/drafts/dsl-idris.pdf)

[Idris â€“ Systems Programming meets Full Dependent Types](http://eb.host.cs.st-andrews.ac.uk/writings/plpv11.pdf)

Could we use Idris to build a verified file system?

</xmp>
<script src="assets/strapdown.js"></script>
</html>
